# -*- coding: utf-8 -*-
"""Souhardya 1134 Assignment

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/souhardya-1134-assignment-5135b30f-07d3-49d3-a0aa-0ad3f26766a3.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20240524/auto/storage/goog4_request%26X-Goog-Date%3D20240524T232152Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D0c2a37cfb27b41ec8dfe7a99b8bd3d333d71f7b9ef9e12fe468bab78bec0a2ca7c08b66f0937e10587698c056bed2854995d967177bffd34abcf1fffd399466dcb2ce3913a2cfc9ad1561a00968dcc8ac4522991270695d0f42682c823cc30091916b720f192bbc36151babd7c17803f202297f565e0d9491c848998a13efc0e1588001c87b398782ecf91cfd54e14c2e3cfca8f302187fb6e707bee50041acdd67a4d15a90fca253c99bb1ba66eb7993a6ba39ac256432a81ad5873ce55f5949b836f3a70c68ed511c7b8318f038929906fdbdeff1643379a88fc7ef19aaf2c23c820acd953a865d55bf71d085513c85eb10716ee4a122135b5450f00b16df3
"""

# %% [code] {"execution":{"iopub.status.busy":"2024-05-24T22:28:38.942749Z","iopub.execute_input":"2024-05-24T22:28:38.943273Z","iopub.status.idle":"2024-05-24T22:28:38.953654Z","shell.execute_reply.started":"2024-05-24T22:28:38.943240Z","shell.execute_reply":"2024-05-24T22:28:38.952337Z"},"jupyter":{"outputs_hidden":false}}
def parse_entry(entry):
    op=int(entry[0])
    entry=entry[2:]
    if op == 1:
        entry=entry.split(';')
        return [1,{'time':int(entry[0]),'log_type':entry[1],
                'severity':float(entry[2])}]
    entry=entry.split(' ')
    if op == 2:
        return [2,{'log_type':entry[0]}]
    if op == 3:
        return [3,{'action':entry[0],'time':int(entry[1])}]
    if op == 4:
        return [4,{'action':entry[0],'log_type':entry[1],'time':int(entry[2])}]

# %% [code] {"execution":{"iopub.status.busy":"2024-05-24T22:28:41.115327Z","iopub.execute_input":"2024-05-24T22:28:41.115832Z","iopub.status.idle":"2024-05-24T22:28:41.134690Z","shell.execute_reply.started":"2024-05-24T22:28:41.115783Z","shell.execute_reply":"2024-05-24T22:28:41.133263Z"},"jupyter":{"outputs_hidden":false}}
def sol(i,entry_dict):
    op,parsed=parse_entry(i)
    if op == 1:
        entry_dict[(parsed['time'],parsed['log_type'])]=parsed['severity']
        return entry_dict
    if op == 2:
        sev_arr=[]
        log_type=parsed['log_type']
        for keys,val in entry_dict.items():
            if keys[1]==log_type:
                sev_arr.append(val)
        if not sev_arr:
                sev_arr=[0.0]
        return([min(sev_arr),max(sev_arr),sum(sev_arr)/len(sev_arr)])
    if op == 3:
        sev_arr=[]
        time=parsed['time']
        if parsed['action']=='BEFORE':
            for keys,val in entry_dict.items():
                if keys[0]<time:
                    sev_arr.append(val)
            if not sev_arr:
                sev_arr=[0.0]
            return([min(sev_arr),max(sev_arr),sum(sev_arr)/len(sev_arr)])
        else:
            for keys,val in entry_dict.items():
                if keys[0]>time:
                    sev_arr.append(val)
            if not sev_arr:
                sev_arr=[0.0]
            return([min(sev_arr),max(sev_arr),sum(sev_arr)/len(sev_arr)])
    if op == 4:
        sev_arr=[]
        time=parsed['time']
        log_type=parsed['log_type']
        if parsed['action']=='BEFORE':
            for keys,val in entry_dict.items():
                if keys[0]<time and keys[1]==log_type:
                    sev_arr.append(val)
            if not sev_arr:
                sev_arr=[0.0]
            return([min(sev_arr),max(sev_arr),sum(sev_arr)/len(sev_arr)])
        else:
            for keys,val in entry_dict.items():
                if keys[0]>time and keys[1]==log_type:
                    sev_arr.append(val)
            if not sev_arr:
                sev_arr=[0.0]
            return([min(sev_arr),max(sev_arr),sum(sev_arr)/len(sev_arr)])

# %% [code] {"execution":{"iopub.status.busy":"2024-05-24T22:31:26.804509Z","iopub.execute_input":"2024-05-24T22:31:26.804919Z","iopub.status.idle":"2024-05-24T22:31:26.820591Z","shell.execute_reply.started":"2024-05-24T22:31:26.804881Z","shell.execute_reply":"2024-05-24T22:31:26.819170Z"},"jupyter":{"outputs_hidden":false}}
import random

def generate_test_input(num_entries):
    types = ['ERROR', 'WARNING', 'INFO', 'DEBUG', 'CRITICAL', 'ALERT',
             'NOTICE', 'EMERGENCY', 'TRACE', 'FATAL', 'SECURITY', 'AUDIT',
             'INFO', 'PERFORMANCE', 'CONFIG']
    timestamp = 1
    with open('input.txt', 'w') as file:
        for _ in range(30):
            log_type = random.choice(types)
            timestamp += random.randint(1,5)
            severity = round(random.uniform(1e-6,1e6),2)
            file.write(f"1 {timestamp};{log_type};{severity}\n")
        for _ in range(num_entries):
            choice = random.choices([1, 2, 3, 4], weights=[0.4, 0.3, 0.15, 0.15])[0]
            if choice == 1:
                log_type = random.choice(types)
                severity = round(random.uniform(1e-6,1e6),2)
                timestamp += random.randint(1,5)
                file.write(f"1 {timestamp};{log_type};{severity}\n")
            elif choice == 2:
                log_type = random.choice(types)
                file.write(f"2 {log_type}\n")
            elif choice == 3:
                subcommand = random.choice(['BEFORE', 'AFTER'])
                timestamp += random.randint(1,5)
                file.write(f"3 {subcommand} {timestamp-30}\n")
            elif choice == 4:
                subcommand = random.choice(['BEFORE', 'AFTER'])
                log_type = random.choice(types)
                timestamp += random.randint(1,5)
                file.write(f"4 {subcommand} {log_type} {timestamp-30}\n")
if __name__ == "__main__":
    generate_test_input(300)

# %% [code] {"execution":{"iopub.status.busy":"2024-05-24T22:50:40.083017Z","iopub.execute_input":"2024-05-24T22:50:40.083440Z","iopub.status.idle":"2024-05-24T22:50:40.092339Z","shell.execute_reply.started":"2024-05-24T22:50:40.083409Z","shell.execute_reply":"2024-05-24T22:50:40.090938Z"},"jupyter":{"outputs_hidden":false}}
def final_sol(in_file_path,out_file_path='output.txt'):
    with open(in_file_path, 'r') as input_file:
        input_lines = [s[:-1] for s in input_file.readlines()]
    output=[]
    entry_dict={}
    for i in input_lines:
        if i[0]=='1':
            entry_dict=sol(i,entry_dict)
        else:
            output.append(sol(i,entry_dict))
    with open(out_file_path, 'w') as output_file:
        for result in output:
            output_file.write(f"Min: {result[0]}, Max: {result[1]}, Mean: {round(result[2],6)}\n")

# %% [code] {"execution":{"iopub.status.busy":"2024-05-24T23:03:07.356742Z","iopub.execute_input":"2024-05-24T23:03:07.357263Z","iopub.status.idle":"2024-05-24T23:03:07.364590Z","shell.execute_reply.started":"2024-05-24T23:03:07.357221Z","shell.execute_reply":"2024-05-24T23:03:07.362978Z"}}
#EXAMPLE:

final_sol('/kaggle/working/input.txt','/kaggle/working/output.txt')